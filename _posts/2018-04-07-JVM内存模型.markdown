---
layout:     post
title:      "JVM内存模型"
subtitle:   " \"人生就像一场马拉松，跑到最后才是赢家。\""
date:       2018-04-07 16:24:00
author:     "Leon"
header-img: "img/2018-04-03-posts-bg.jpg"
catalog: true
tags:
    - JVM
---

> “Anyway, anyhow. ”


### 运行时区域
![Java虚拟机运行时数据区](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1506681962929&di=5507dec066bddfb28557b8ed2a309c7a&imgtype=0&src=http%3A%2F%2Fimages2015.cnblogs.com%2Fblog%2F665375%2F201601%2F665375-20160126212928129-1855187537.png)
#### 程序计数器
程序计数器是一块比较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理等基础功能需要依赖这个计数器完成。

Java虚拟机在任一确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的线程计数器。所以也称这类内存区为“线程私有”的内存。

如果线程在执行Java方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，则值为空。该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域。

#### 虚拟机栈
与程序计数器一样，虚拟机栈也是线程私有的，它的生命周期与线程相同。

虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机可以动态扩展。如果扩展时无法申请到足够的内存，就会OOM。

#### 本地方法栈
本地方法栈与虚拟机栈只不过一个执行的是Native方法，一个执行的是Java方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构没有强制规定。与虚拟机栈一样，该区域会抛StackOverflowError和OOM。

有些虚拟机把本地方法栈和虚拟机栈合二为一，例如Sun HotSpot。

#### Java堆
对于大部分应用来说，Java堆是Java虚拟机所管理的内存中最大的一块，被所有的线程共享，在虚拟机启动时创建。

Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域。Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。

如果在堆中没有内存完成实例分配，并且堆也无法再扩展时将会抛出OOM。

#### 方法区
与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小和可扩展之外，还可以选择不实现垃圾收集。


##### 运行时常量池
运行时常量池是方法区的一部分。除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时的常量池中。

当常量池无法再申请到内存是会抛出OOM。
