---
layout:     post
title:      "解读阿里一面面经-牛客网"
subtitle:   " \"人生就像一场马拉松，跑到最后才是赢家。\""
date:       2018-04-05 17:38:00
author:     "Leon"
header-img: "img/2018-04-03-posts-bg.jpg"
catalog: true
tags:
    - 面经
---

> “Anyway, anyhow. ”


## 来源

[阿里一面面经 牛客网](https://www.nowcoder.com/discuss/68447)

## 解答

Maven中两个冲突包依赖其他包，如何处理？

依赖冲突的产生：
因为依赖的传递性。A->B->C(V1.1); A->D->C(V1.2)。如果依赖C有多个版本，就会产生冲突。

Maven依赖选取原则：
**最短路径**：A->B->C(V1.1)；A->B->E->C(V1.2)。依赖C的版本为V1.1。
**最先声明**：A->B->C(V1.1); A->D->C(V1.2)。如果在A中先声明对B的依赖，则A对C的依赖为V1.1。

**分析方法**：
使用``dependency:tree``分析依赖。
使用``mvn dependency:tree -Dverbose``查看更多信息，尤其是conflict信息。

**解决方法**：
缩短指定版本的路径/ exclude掉不想要的版本/ 将依赖声明为optional

---

pom.xml中有哪些配置？

什么是Maven
Maven是一个采用纯Java编写的开源项目管理工具, Maven采用了一种被称之为Project Object Model (POM)概念来管理项目，所有的项目配置信息都被定义在一个叫做POM.xml的文件中。
**Maven是一款跨平台的项目管理工具，**是一个开源的项目。Maven主要服务于基于Java平台的项目构建、依赖管理和项目信息管理。

POM怎么理解呢？

我们使用Java是面向对象编程，对象就是我们的类，而Maven是**面向项目**，把我们的项目看做成是一个对象来进行管理。

Maven可以管理项目的整个声明周期，包括清除、编译，测试，报告、打包、部署等等。

自动构建项目
- 软件开发： 可行性分析、需求分析、软件设计、软件开发、发布、运维
- 软件构建： 软件已经开发完毕，需要构建成一个产品进行发布 构建步骤：
- 清除--> 编译-->测试-->报告-->打包（jar\war）-->安装-->部署到远程**maven可以通过一个命令实现自动构建软件项目**

pom文件：
1.坐标的组成： groupId + artifactId+ version
- groupId：组id ,机构名，公司名：好比公司的id，或者是公司包名 alibaba ——-》高德--》5.01版本
- artifactId：构建物id ，产品名或者产品的id
- version ：版本号
1.jar包组成： artifactId-version.jar

``
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <!-- 指定当前pom的版本 -->
  <modelVersion>4.0.0</modelVersion>
  
  <!-- 一、项目的坐标信息-->
  <groupId>反写的公司网址+项目名</groupId>
  <artifactId>项目名+模块名</artifactId>
  <!--
    第一个o:大版本:号
    第二个0：分支版本号
    第三个0：小版本号
    版本类型划分：1.SNAPSHOT(快照) 
                  2.alpha（内测）
                  3.beta（公测）
                  4.Release（稳定）
                  5.GA（正式）
  -->
  <version>0.0.1SNAPSHOT</version>
  <!--maven项目打包方式：默认：jar，可指定war、zip、pom--->
  <packaging></packaging>
  <!--项目描述名-->
  <name></name>
  <!--项目地址-->
  <url></url>
  <!--项目描述-->
  <description></description>
  <!--开发人员信息-->
  <developers></developers>
  <!--许可证信息-->
  <licenses></licenses>
  <!--组织信息-->
  <organization></organization>

  <!--二、依赖列表-->
  <dependencies>
      <!--依赖坐标-->
      <dependency>
          <groupId>junit</groupId>
          <artifactId>junit</artifactId>
          <version>4.10</version>
          <type></type>
          <!-- 依赖范围：test-->
          <scope>test</scope>
          <!--设置依赖是否可选:true/false默认是后者-->
          <optional>false</optional>
          <!--排除依赖传递列表-->
          <exclusions>
              <!--排除部分不需要的依赖-->
              <exclusion></exclusion>
          </exclusions>
      </dependency>
  </dependencies>

  <!--三、依赖的管理:定义父模块的jar包便于子模块的继承-->
  <dependencyManagement>
      <dependencies>
        <dependency></dependency>
      </dependencies>
  </dependencyManagement>

  <!--四、插件列表:需指定插件的坐标-->
  <build>
      <plugin>
          <groupId></groupId>
          <artifactId></artifactId>
          <version></version>
      </plugin>
  </build>

  <!--五、用于子模块对于父模块pom的继承-->
  <parent></parent>

  
  <!--六、指定多个模块，可同时编译等操作-->
  <modules></modules>
</project>
``

scope应用范围有test、compile等等，默认是compile，那么test和compile有什么区别呢？

间接依赖问题 ：依赖的jar包必须是 compile 范围，假如是test范围，则发布的jar包不会包含test范围依赖的jar包，和依赖关系<scope>test</scope>。

转载：
- https://zhuanlan.zhihu.com/p/34316460
- https://my.oschina.net/zjllovecode/blog/1789907

---

说说string,stringbuilder,stringbuffer。
string中加号连接符是怎么执行的。
string为什么是不可变性？

String字符串是常量。String对象的值是放在JVM方法区的常量池里面的(方法区存放类的信息：版本、字段、方法、接口；常量池：符号引用和字面量；静态变量)。修改String对象的值，就相当于重新new一个String对象出来。频繁修改String对象的值可能会触发JVM的GC，影响系统的性能。因此需要频繁修改字符串的值，我们可以使用StringBuilder和StringBuffer类。

StringBuffer是线程安全的。修改StringBuffer的值不会产生新的对象。StringBuffer有一个字符串缓冲区，这个缓冲区可以安全地应用在多线程当中，只有调用特定的方法才能改变缓冲区的值。

StringBuilder 是非线程安全的。StringBuilder被设计出来，就是简易替代StringBuffer的。在单线程的情况下，StringBuilder会更快，但是它不是线程安全的。它和StringBuffer的方法基本相同。

String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接。在特定的情况下，在 JVM 眼里，这个``String S1 = “This is only a” + “ simple” + “test”; ``其实就是：``String S1 = “This is only a simple test”;``也就是说利用+直接连接两个字符串常量，虚拟机会直接把这两个字符串连接起来看成一个字符串。

在java的世界里，String是作为类出现的，核心的一个域就是一个char数组，内部就是通过维护一个不可变的char数组，来向外部输出的。
这是jdk一段String类定义，首先类是final，表明类不可被继承；核心域是private final的，final表明这个引用所指向的内存地址不会改变，但这还不足说明value[]是不可变的；因为引用所指向的内存的值有可能发生变化，但是jdk是不会让这样的事情发生的。private 保证这个域对外部来说是不可见的，这还不够，对value还要进行 保护性拷贝。参数是一个char数组引用，它并没有把这个数组引用直接赋值给实例对象的value成员变量，而是通过一个Arrays.copyOf的方式拷贝一个数组再给到对象的成员变量。

首先类相关的信息肯定是放在方法区的，堆中放一些实例对象，程序计数器始终指向下一条将要执行的指令，虚拟机栈和本地方法栈分别是用来于普通方法和本地方法的。

着重说一下虚拟机栈，它是线程私有的，描述的是java方法执行的内存模型：每个方法在执行的同时创建一个栈帧，用于存放局部变量表，操作数栈，方法入口，动态链接等。

 

 局部变量表用来存放一些基本数据类，和引用。操作数栈的话，是用来作运算用的，打个比方

```
int a=1;
int b =2;
int c =a+b;
```
JVM会先把a,b的值压入到操作数栈保存起来，等到程序计数器执行加法指令的时候，再把a,b从栈中pop出来。重点就在于a,b值是从哪里压入到栈中的，如果没有``char[] val = value;/* avoid getfield opcode */``那么接下来要遍历的就是value数组了，value毫无疑问是堆中的数据，也就是每一次遍历会经历，数据由堆中取出，进入栈帧，再由栈帧压入到操作数栈，最后pop出来进行运算。

如果执行了上述代码，情况就大不相同了，val就是一个局部变量，它会被存放在局部变量表中，接来下的运算，就是局部变量表到操作数栈了，属于一个栈帧内的数据转移。JVM为了避免频繁进行堆栈数据转移，将值复制到本地变量一次，以避免在接下来的几行中循环的每一次迭代，从堆中多次取下的字段值。

---

JVM内存模型
<img class="shadow" src="/img/JVM内存模型.jpg" width="260">