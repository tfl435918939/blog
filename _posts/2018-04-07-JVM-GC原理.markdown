---
layout:     post
title:      "JVM GC原理"
subtitle:   " \"人生就像一场马拉松，跑到最后才是赢家。\""
date:       2018-04-07 21:03:00
author:     "Leon"
header-img: "img/2018-04-03-posts-bg.jpg"
catalog: true
tags:
    - JVM
---

> “Anyway, anyhow. ”


## 什么是GC？
GC就是垃圾收集(Garbage Collection)，就是要把垃圾所占用的空间都给释放掉。在Java程序中，JVM要为每个对象分配内存资源。如果不做GC，那么系统的资源将会被耗尽，这不是我们想看到的。所以GC是非常有必要的。
我们知道JVM的内存模型是可以分为线程共享和线程私有区域。线程私有区域包括程序计数器，虚拟机栈和本地方法栈。它们随线程而生，随线程而死。这些区域的内存分配和回收都是确定的。线程共享区域包括方法区和堆。因为Java本身的语言特性，只有在程序的运行期间才能知道会创建哪些对象，这些区域的内存分配和回收都是动态的。所以GC最主要关注的是这部分内存。

很显然，不能等到系统内存资源快要耗尽的时候将所有的资源回收再重新分配。那么问题来了，什么时候做GC？如何确定哪些对象是“垃圾”？采取什么样的方式回收？

## 哪些对象是“垃圾”？

##### 引用计数法
在Java中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然可以通过引用计数来判断一个对象是否可以被回收。不失一般性，如果一个对象没有任何引用与之冠梁，则说明该对象基本不太可能在其他被使用到，那么这个对象就成为可被回收的对象了。这种判断对象是否为“垃圾”的方法称为**引用计数法**。

这种方式的特点是实现简单，而且效率较高，但是它无法解决循环引用的问题。比如A引用B，B引用A。

##### 可达性分析法
为了解决循环引用问题，在Java中采取了**可达性分析法**。该方法的基本思想是通过一系列的**“GC Roots”对象**作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。

因为有可能在第一次标记之后，该标记对象被其他对象所引用，如果不标记两次就进行GC，就会报空指针异常。

##### Mark-Sweep（标记-清除）算法

这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。
- 标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。
- 清除：清除的过程将**遍历**堆中所有的对象，将没有标记的对象全部清除掉。

具体过程如下图所示：
![初始状态](http://images.cnitblog.com/blog/558323/201308/19222114-6435e25e050f4a2ea3230879392bdfb3.jpg)

这张图代表的是程序运行期间所有对象的状态，它们的标志位全部是0（也就是未标记，以下默认0就是未标记，1为已标记），假设这会儿有效内存空间耗尽了，JVM将会停止应用程序的运行并开启GC线程，然后开始进行标记工作，按照根搜索算法，标记完以后，对象的状态如下图。

![标记](http://images.cnitblog.com/blog/558323/201308/19222543-1da7fb7bc5d24fd18872a267b65e939e.jpg)

可以看到，按照根搜索算法，所有从root对象可达的对象就被标记为了存活的对象，此时已经完成了第一阶段标记。接下来，就要执行第二阶段清除了，那么清除完以后，剩下的对象以及对象的状态如下图所示。

![清除](http://images.cnitblog.com/blog/558323/201308/19222820-8eca1c1518754d8fac6da532b13f746b.jpg)

可以看到，没有被标记的对象将会回收清除掉，而被标记的对象将会留下，并且会将标记位重新归0。接下来就不用说了，唤醒停止的程序线程，让程序继续运行即可。

其实这一过程并不复杂，甚至可以说非常简单，各位说对吗。不过其中有一点值得一提，就是为什么非要停止程序的运行呢？这个其实也不难理解，举个最简单的例子，假设我们的程序与GC线程是一起运行的，各位试想这样一种场景。

假设我们刚标记完图中最右边的那个对象，暂且记为A，结果此时在程序当中又new了一个新对象B，且A对象可以到达B对象。但是由于此时A对象已经标记结束，B对象此时的标记位依然是0，因为它错过了标记阶段。因此当接下来轮到清除阶段的时候，新对象B将会被苦逼的清除掉。如此一来，不难想象结果，GC线程将会导致程序无法正常工作。GC stop the 
上面的结果当然令人无法接受，我们刚new了一个对象，结果经过一次GC，忽然变成null了，这还怎么玩？所以在GC过程中，有一个非常重要的操作——STW(Stop The World)。

---

##### STW
在执行垃圾收集算法时，Java应用程序的其他所有除了垃圾收集收集器线程之外的线程都会被挂起。此时，系统只能允许GC线程进行运行，其他线程则会全部暂停在一个**安全点**上，等待GC线程完毕后才能再次运行。这些工作都是由虚拟机在后台自动发起和自动完成。在用户不可见的情况下把用户正常工作的线程全部停下来，这对于很多Application来说，尤其是那些对于实时性要求很高的程序来说难以接受。虽然随着JVM的发展，STW的时间越来越短，但是STW是无法避免的。

对于很多的垃圾收集器来说，都会采用Stop the World机制来进行垃圾回收。具体来讲，在Java虚拟机的Serial, ParNew, Parallel Scanvange, ParallelOld, Serial Old全程都会Stop the world，JVM这时候只运行GC线程，不运行用户线程。而CMS主要分为 initial Mark, Concurrent Mark, ReMark,Concurrent Sweep等阶段，initial Mark和Remark占整体的时间比较较小，它们会Stop the world. Concurrent Mark和Concurrent Sweep会和用户线程一起运行。虽然CMS减少了stop the world的次数，不可避免地让整体GC的时间拉长了。

Serial：单线程STW，复制算法。
ParNew：多线程并行STW，复制算法。
Parallel Scavange：多线程并行STW，吞吐量优先，复制算法。
G1：多线程并发，可以精确控制STW时间，整理算法。

---

从图中可以很容易看出标记-清除算法实现起来比较容易，但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。

##### Copying（复制）算法

为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示：
![清理前](http://images2015.cnblogs.com/blog/872419/201608/872419-20160808112644824-97750125.png)

![清理后](http://images2015.cnblogs.com/blog/872419/201608/872419-20160808112644824-97750125.png)

这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。

很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。

IBM公司研究表明，新生代中的对象98%都是“朝生夕死”的。HotSpot虚拟机中将内存分为一块比较大的Eden空间和两块比较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。

##### Mark-Compact（标记-整理）算法

为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：
![整理前](http://img.blog.csdn.net/20161101222342412)

##### Generational Collection（分代收集）算法

分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

目前大部分垃圾收集器对于新生代都采取Copying算法。而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。

注意，在堆区之外还有一个代就是永久代（Permanet Generation），它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。

内附一篇对JVM分代收集算法有独到见解的文章：
http://www.cnblogs.com/zgghb/p/6428395.html

#### [垃圾收集器](http://www.importnew.com/23035.html)
垃圾收集器是内存回收的具体实现。

![HotSpot 垃圾收集器](http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg)