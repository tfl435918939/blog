---
layout:     post
title:      "线程池相关"
subtitle:   " \"人生就像一场马拉松，跑到最后才是赢家。\""
date:       2018-04-08 16:24:00
author:     "Leon"
header-img: "img/2018-04-03-posts-bg.jpg"
catalog: true
tags:
    - 并发
---

> “Anyway, anyhow. ”

[本文参考文献：Java集合-ConcurrentHashMap工作原理和实现JDK8](https://www.jianshu.com/p/85d158455861)

### 使用 Executors 创建线程池
我们先来看看ThreadPoolExecutor参数最全的构造方法：
```
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```
- corePoolSize：线程池的核心线程数，说白了就是，即便是线程池里没有任何任务，也会有corePoolSize个线程在候着等任务。
- maximumPoolSize:最大线程数，不管你提交多少任务，线程池里最多工作线程数就是maximumPoolSize。
- keepAliveTime:线程的存活时间。当线程池里的线程数大于corePoolSize时，如果等了keepAliveTime时长还没有任务可执行，则线程退出。
- unit：这个用来指定keepAliveTime的单位，比如秒:TimeUnit.SECONDS。
- workQueue：一个阻塞队列，提交的任务将会被放到这个队列里。
- threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。
- handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。
以上就是创建线程池时用到的参数，面试中经常会有面试官问道这个问题。

### 线程池执行流程
如图：
<img class="shadow" src="/blog/img/ThreadPoolExcutor.jpg" width="780" height="390">
任务被提交到线程池，会判断当前线程的数量是否小于``corePoolSize``，如果小于则创建线程来执行提交的任务，否则将任务放入``workQueue``队列，如果``workQueue``满了，则判断当前线程数量是否小于``maximumPoolSize``,如果小于则创建线程执行任务，否则调用``handler``，表示线程池拒绝接收的任务。
#### 线程池的executor方法
```
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        //判断当前活跃线程数是否小于corePoolSize,如果小于，则调用addWorker创建线程执行任务
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        //如果不小于corePoolSize，则将任务添加到workQueue队列
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        //如果放入workQueue失败，则创建线程执行任务，如果这时创建线程失败(当前线程数不小于maximumPoolSize时)，就会调用reject(内部调用handler)拒绝接受任务
        else if (!addWorker(command, false))
            reject(command);
    }
```
总结：
- 判断当前活跃线程数是否小于corePoolSize,如果小于，则调用addWorker创建线程执行任务。
- 如果不小于corePoolSize，则将任务添加到workQueue队列。
- 如果放入workQueue失败，则创建线程执行任务，如果这时创建线程失败(当前线程数不小于maximumPoolSize时)，就会调用reject(内部调用handler)拒绝接受任务。

#### addWorker方法相关
这块代码是在创建非核心线程时，即core等于false。判断当前线程数是否大于等于maximumPoolSize，如果大于等于则返回false，即上边说到的创建线程失败的情况。否则创建Worker对象，同时也会实例化一个Thread对象。然后启动这个线程。
```
/**
         * Creates with given first task and thread from ThreadFactory.
         * @param firstTask the first task (null if none)
         */
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

        /** Delegates main run loop to outer runWorker  */
        public void run() {
            runWorker(this);
        }
```
创建Worker时会调用threadFactory来创建一个线程。启动一个线程就会触发Worker的run方法被线程调用。线程调用runWoker，会while循环调用getTask方法从workerQueue里读取任务，然后执行任务。只要getTask方法不返回null,此线程就不会退出。
getTask方法中，如果当前线程数大于corePoolSize，则会调用workQueue的poll方法获取任务，超时时间是keepAliveTime。如果超过keepAliveTime时长，poll返回了null，上边提到的while循序就会退出，线程也就执行完了。
如果当前线程数小于corePoolSize，则会调用workQueue的take方法阻塞在当前。

#### 创建固定大小的线程池
源码分析：
```
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(
            nThreads,
            nThreads,
            0L,
            TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>());
}
```
当``corePoolSize``满了之后就加到``LinkedBlockingQueue``队列中。每当线程池中的某个线程执行完成之后，就从``LinkedBlockingQueue``队列取一个。

#### 创建单线程化的线程池
```
public static ExecutorService newSingleThreadExecutor() {
    return new Executors.FinalizableDelegatedExecutorService
            (
                    new ThreadPoolExecutor(
                            1,
                            1,
                            0L,
                            TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>())
            );
}

public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
            Executors.defaultThreadFactory(), defaultHandler);
}
```
原理同``newSingleThreadPool()``。

#### 创建可缓冲的线程池
```
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(
            0,
            Integer.MAX_VALUE,
            60L,
            TimeUnit.SECONDS,
            new SynchronousQueue<Runnable>());
}
```
由于corePoolSize为0所以任务会放入SynchronousQueue队列中，SynchronousQueue只能存放大小为1，所以会立刻新起线程，由于maxumumPoolSize为Integer.MAX_VALUE所以可以认为大小为2147483647。受内存大小限制。

### 阻塞队列
阻塞队列是一个在队列基础上又支持了两个附加操作的队列。

2个附加操作：

支持阻塞的插入方法：队列满时，队列会阻塞插入任务的线程，直到队列不满。
支持阻塞的移除方法：队列空时，获取任务的线程会等待队列变为非空。

阻塞队列的应用场景
阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加任务的线程，消费者是从队列里取任务的线程。简而言之，阻塞队列是生产者用来存放元素、消费者获取任务的容器。

### 拒绝策略
ThreadPoolExecutor默认有四个拒绝策略：

1、``ThreadPoolExecutor.AbortPolicy() ``直接抛出异常RejectedExecutionException，默认值

2、``ThreadPoolExecutor.CallerRunsPolicy() ``直接调用run方法并且阻塞执行

3、``ThreadPoolExecutor.DiscardPolicy() ``直接丢弃后来的任务

4、``ThreadPoolExecutor.DiscardOldestPolicy() ``丢弃在队列中队首的任务

当然可以自己继承RejectedExecutionHandler来写拒绝策略。